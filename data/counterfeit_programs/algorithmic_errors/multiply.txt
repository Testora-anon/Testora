# Prompt 1:

Consider this Python function:

def multiply(a, b):
    """Complete the function that takes two integers and returns
    the product of their unit digits.
    Assume the input is always valid.
    Examples:
    multiply(148, 412) should return 16.
    multiply(19, 28) should return 72.
    multiply(2020, 1851) should return 0.
    multiply(14,-15) should return 20.
    """
    return a % 10 * b % 10

Provide a pre-condition for the function that fails when the function gets called with an incorrect input.
    

# Augmented program based on the predicted pre-condition:

def multiply(a, b):
    """Complete the function that takes two integers and returns
    the product of their unit digits.
    Assume the input is always valid.
    Examples:
    multiply(148, 412) should return 16.
    multiply(19, 28) should return 72.
    multiply(2020, 1851) should return 0.
    multiply(14,-15) should return 20.
    """
    # Precondition: check that a and b are integers
    if not isinstance(a, int) or not isinstance(b, int):
        raise TypeError("Both arguments must be integers")
    return a % 10 * b % 10


# Prompt 2:
    
Consider this Python function:

def multiply(a, b):
    """Complete the function that takes two integers and returns
    the product of their unit digits.
    Assume the input is always valid.
    Examples:
    multiply(148, 412) should return 16.
    multiply(19, 28) should return 72.
    multiply(2020, 1851) should return 0.
    multiply(14,-15) should return 20.
    """
    # Precondition: check that a and b are integers
    if not isinstance(a, int) or not isinstance(b, int):
        raise TypeError("Both arguments must be integers")
    return a % 10 * b % 10

Do you see any bugs in this function?
Focus on logic errors and missing corner cases.
Provide your answer as an enumerated list, with one bug on each line.


# Useful hypothesis obtained in second sample:

There is a precedence issue with the modulus operator (%). The expression a % 10 * b % 10 will first compute a % 10, then multiply it by b, and finally calculate the modulus of the result with 10. This may lead to incorrect results when the product of the unit digits exceeds 10.


# Prompt 3:

Consider this Python function:

def multiply(a, b):
    """Complete the function that takes two integers and returns
    the product of their unit digits.
    Assume the input is always valid.
    Examples:
    multiply(148, 412) should return 16.
    multiply(19, 28) should return 72.
    multiply(2020, 1851) should return 0.
    multiply(14,-15) should return 20.
    """
    # Precondition: check that a and b are integers
    if not isinstance(a, int) or not isinstance(b, int):
        raise TypeError("Both arguments must be integers")
    return a % 10 * b % 10

The function has a bug:
There is a precedence issue with the modulus operator (%). The expression a % 10 * b % 10 will first compute a % 10, then multiply it by b, and finally calculate the modulus of the result with 10. This may lead to incorrect results when the product of the unit digits exceeds 10.

Here is a test case that exposes this bug:


# Predicted test case:

def test_multiply():
    # Test case 1: General case with positive integers
    assert multiply(148, 412) == 16  # (8 * 2)

    # Test case 2: General case with positive integers
    assert multiply(19, 28) == 72  # (9 * 8)

    # Test case 3: General case with a positive and a negative integer
    assert multiply(14, -15) == 20  # (4 * 5)

    # Test case 4: Both integers have a unit digit of zero
    assert multiply(2020, 1851) == 0  # (0 * 1)

    # Test case 5: General case with zeros
    assert multiply(0, 0) == 0  # (0 * 0)
    
    # Test case 6: Both integers have the same unit digit
    assert multiply(33, 93) == 9  # (3 * 3)

--> Test fails and exposes the problem


# Prompt for test case without any hypothesis or precondition:

Consider this Python function:

def multiply(a, b):
    """Complete the function that takes two integers and returns
    the product of their unit digits.
    Assume the input is always valid.
    Examples:
    multiply(148, 412) should return 16.
    multiply(19, 28) should return 72.
    multiply(2020, 1851) should return 0.
    multiply(14,-15) should return 20.
    """
    return a % 10 * b % 10

Provide a test case for the function, by completing this code snippet:

def test_multiply():
  ...

--> Also produces a test that exposes the error. I.e., test generation works, but no need for precondition and hypothesis.