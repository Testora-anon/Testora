The pull request "Backport PR #57402 on branch 2.2.x (BUG: wrong future Warning on string assignment in certain condition)" of the pandas project changes the pandas.core.dtypes.missing.construct_1d_array_from_inferred_fill_value, pandas.core.indexing._ensure_listlike_indexer, pandas.core.indexing._setitem_with_indexer, pandas.core.indexing._setitem_single_column function(s). Your task is to determine whether this change accidentally introduces a regression bug, i.e., an unintended change in behavior.

# Details about the pull request
## Comments
Comment by meeseeksmachine:
Backport PR #57402: BUG: wrong future Warning on string assignment in certain condition

## Review comments
## Commit messages
Backport PR #57402: BUG: wrong future Warning on string assignment in certain condition



# Diff of the pull request
diff --git a/doc/source/whatsnew/v2.2.1.rst b/doc/source/whatsnew/v2.2.1.rst
index 9733aff0e6..5e814ec2a1 100644
--- a/doc/source/whatsnew/v2.2.1.rst
+++ b/doc/source/whatsnew/v2.2.1.rst
@@ -24,6 +24,7 @@ Fixed regressions
- Fixed regression in :meth:`CategoricalIndex.difference` raising ``KeyError`` when other contains null values other than NaN (:issue:`57318`)
- Fixed regression in :meth:`DataFrame.groupby` raising ``ValueError`` when grouping by a :class:`Series` in some cases (:issue:`57276`)
- Fixed regression in :meth:`DataFrame.loc` raising ``IndexError`` for non-unique, masked dtype indexes where result has more than 10,000 rows (:issue:`57027`)
+- Fixed regression in :meth:`DataFrame.loc` which was unnecessarily throwing "incompatible dtype warning" when expanding with partial row indexer and multiple columns (see `PDEP6 <https://pandas.pydata.org/pdeps/0006-ban-upcasting.html>`_) (:issue:`56503`)
- Fixed regression in :meth:`DataFrame.map` with ``na_action="ignore"`` not being respected for NumPy nullable and :class:`ArrowDtypes` (:issue:`57316`)
- Fixed regression in :meth:`DataFrame.merge` raising ``ValueError`` for certain types of 3rd-party extension arrays (:issue:`57316`)
- Fixed regression in :meth:`DataFrame.shift` raising ``AssertionError`` for ``axis=1`` and empty :class:`DataFrame` (:issue:`57301`)
diff --git a/pandas/core/dtypes/missing.py b/pandas/core/dtypes/missing.py
index 4dc0d477f8..655a539976 100644
--- a/pandas/core/dtypes/missing.py
+++ b/pandas/core/dtypes/missing.py
@@ -647,6 +647,20 @@ def infer_fill_value(val):
return np.nan


+def construct_1d_array_from_inferred_fill_value(
+ value: object, length: int
+) -> ArrayLike:
+ # Find our empty_value dtype by constructing an array
+ # from our value and doing a .take on it
+ from pandas.core.algorithms import take_nd
+ from pandas.core.construction import sanitize_array
+ from pandas.core.indexes.base import Index
+
+ arr = sanitize_array(value, Index(range(1)), copy=False)
+ taker = -1 * np.ones(length, dtype=np.intp)
+ return take_nd(arr, taker)
+
+
def maybe_fill(arr: np.ndarray) -> np.ndarray:
"""
Fill numpy.ndarray with NaN, unless we have a integer or boolean dtype.
diff - -git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 934ba3a4d7..869e511fc0 100644
- -- a/pandas/core/indexing.py
+ ++ b/pandas/core/indexing.py
@ @ -57, 6 + 57, 7 @ @ from pandas.core.dtypes.generic import (
ABCSeries,
)
from pandas.core.dtypes.missing import (
+ construct_1d_array_from_inferred_fill_value,
infer_fill_value,
is_valid_na_for_dtype,
isna,
@ @ -68, 7 + 69, 6 @ @ import pandas.core.common as com
from pandas.core.construction import (
array as pd_array,
extract_array,
- sanitize_array,
)
from pandas.core.indexers import (
check_array_indexer,
@ @ -844, 7 + 844, 6 @ @ class _LocationIndexer(NDFrameIndexerBase):
if self.ndim != 2:
return

- orig_key=key
if isinstance(key, tuple) and len(key) > 1:
# key may be a tuple if we are .loc
# if length of key is > 1 set key to column part
@ @ -862, 7 + 861, 7 @ @ class _LocationIndexer(NDFrameIndexerBase):
keys=self.obj.columns.union(key, sort=False)
diff=Index(key).difference(self.obj.columns, sort=False)

- if len(diff) and com.is_null_slice(orig_key[0]):
+ if len(diff):
# e.g. if we are doing df.loc[:, ["A", "B"]] = 7 and "B"
# is a new column, add the new columns with dtype=np.void
# so that later when we go through setitem_single_column
@ @ -1878, 12 + 1877, 9 @ @ class _iLocIndexer(_LocationIndexer):

self.obj[key]=empty_value
elif not is_list_like(value):
-  # Find our empty_value dtype by constructing an array
-  # from our value and doing a .take on it
- arr=sanitize_array(value, Index(range(1)), copy=False)
- taker=-1 * np.ones(len(self.obj), dtype=np.intp)
- empty_value=algos.take_nd(arr, taker)
- self.obj[key]=empty_value
+ self.obj[key]=construct_1d_array_from_inferred_fill_value(
+ value, len(self.obj)
+ )
else:
# FIXME: GH#42099#issuecomment-864326014
self.obj[key]=infer_fill_value(value)
@ @ -2165, 6 + 2161, 17 @ @ class _iLocIndexer(_LocationIndexer):
else:
# set value into the column (first attempting to operate inplace, then
# falling back to casting if necessary)
+ dtype=self.obj.dtypes.iloc[loc]
+ if dtype == np.void:
+  # This means we're expanding, with multiple columns, e.g.
+  # df = pd.DataFrame({'A': [1,2,3], 'B': [4,5,6]})
+  # df.loc[df.index <= 2, ['F', 'G']] = (1, 'abc')
+  # Columns F and G will initially be set to np.void.
+  # Here, we replace those temporary `np.void` columns with
+  # columns of the appropriate dtype, based on `value`.
+ self.obj.iloc[:, loc]=construct_1d_array_from_inferred_fill_value(
+ value, len(self.obj)
+ )
self.obj._mgr.column_setitem(loc, plane_indexer, value)

self.obj._clear_item_cache()
diff - -git a/pandas/tests/frame/indexing/test_setitem.py b/pandas/tests/frame/indexing/test_setitem.py
index 99233d3cd4..a58dd701f0 100644
- -- a/pandas/tests/frame/indexing/test_setitem.py
+ ++ b/pandas/tests/frame/indexing/test_setitem.py
@ @ -1401, 3 + 1401, 19 @ @ def test_full_setter_loc_incompatible_dtype():
df.loc[:, "a"]={0: 3, 1: 4}
expected=DataFrame({"a": [3, 4]})
tm.assert_frame_equal(df, expected)
+
+
+def test_setitem_partial_row_multiple_columns():
+  # https://github.com/pandas-dev/pandas/issues/56503
+ df=DataFrame({"A": [1, 2, 3], "B": [4.0, 5, 6]})
+  # should not warn
+ df.loc[df.index <= 1, ["F", "G"]]=(1, "abc")
+ expected=DataFrame(
+ {
+ "A": [1, 2, 3],
+ "B": [4.0, 5, 6],
+ "F": [1.0, 1, float("nan")],
+ "G": ["abc", "abc", float("nan")],
+}
+ )
+ tm.assert_frame_equal(df, expected)

# Usage example that changes its behavior
```python
# Example 17: Using loc with a NaN value to set multiple columns
import pandas as pd

df=pd.DataFrame({'A': [1, 2, 3], 'B': [4.0, 5, 6]})
df.loc[df.index <= 1, ["F", "G"]]=(None, None)
print(df)
```

# Output of the usage example before the change
A B F G
0 1 4.0 NaN NaN
1 2 5.0 NaN NaN
2 3 6.0 NaN NaN


# Output of the usage example after the change
A B F G
0 1 4.0 None None
1 2 5.0 None None
2 3 6.0 NaN NaN


# Task
You should explain your reasoning and then answer five questions:
1) Is the different output a noteworthy change in behavior, as opposed to, e.g., a minor change in formatting? Answer either "minor" or "noteworthy".
2) Is the different output likely due to non-determinism, e.g., because of random sampling or a non-deterministically ordered set? Answer either "deterministic" or "non-deterministic".
3) Does the usage example refer only to public APIs of pandas, or does it use any project-internal functionality? Answer either "public" or "project-internal".
4) Does the usage example pass inputs as intended by the API documentation, or does it pass any illegal(e.g., type-incorrect) inputs? Answer either "legal" or "illegal".
5) Is the different output intended by the developer of the pull request, or is the change in behavior rather surprising? Answer either "intended" or "surprising".
Explain your reasoning and then give your answers in the following format:
< THOUGHTS >
...
< /THOUGHTS >
< ANSWER1 >
...
< /ANSWER1 >
< ANSWER2 >
...
< /ANSWER2 >
< ANSWER3 >
...
< /ANSWER3 >
< ANSWER4 >
...
< /ANSWER4 >
< ANSWER5 >
...
< /ANSWER5 >